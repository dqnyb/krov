from openai import OpenAI
from flask import Flask, request, jsonify
from flask_cors import CORS
from openpyxl import Workbook, load_workbook
from datetime import datetime
import openai
import pandas as pd
import os
import random
from dotenv import load_dotenv
import pandas as pd
from thefuzz import fuzz
from thefuzz import process
import test
from test import categoria_preferata
import re
from difflib import SequenceMatcher

app = Flask(__name__)
CORS(app)

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = OPENAI_API_KEY
# Pentru acest proiect am lÄƒsat cheia publicÄƒ (pentru a fi testatÄƒ mai repede), dar desigur cÄƒ nu se face aÈ™a!
# AÈ™ fi folosit client = OpenAI(api_key=os.getenv("OPENAI_API_KEY")) È™i aÈ™ fi dat export Ã®n env la key: export OPENAI_API_KEY="sk-..."

client = OpenAI(
    api_key=OPENAI_API_KEY,  # pune aici cheia ta realÄƒ!
)

preferinte = {}

df = pd.read_excel('p.xlsx')
categorii = df['Categorie']
categorii_unice = list(dict.fromkeys(categorii.dropna().astype(str)))

# print(categorii_unice)
def log_message(sender, message):
    # CreeazÄƒ calea absolutÄƒ cÄƒtre folderul logs ! Pentru a salva log-urile in excel !
    base_dir = os.path.expanduser("../logs")
    os.makedirs(base_dir, exist_ok=True)
    file_path = os.path.join(base_dir, "chat_log1.xlsx")

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    new_row = {"Timestamp": timestamp, "Sender": sender, "Message": message}

    try:
        if os.path.exists(file_path):
            df = pd.read_excel(file_path)
            df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)
        else:
            df = pd.DataFrame([new_row])

        df.to_excel(file_path, index=False)
        print(f"[{timestamp}] [LOGGED] {sender}: {message}")
    except Exception as e:
        print(f"[EROARE] Logarea a eÈ™uat: {e}")


@app.route("/start", methods=["GET"])
def start():
    welcome_message = (
        "Salut! ğŸ‘‹ Cu ce te pot ajuta? Vrei detalii despre un produs sau doreÈ™ti sÄƒ plasezi o comandÄƒ?"
    )
    return jsonify({"ask_name": welcome_message})

def check_interest(interest):
    interests_prompt = (
        "AnalizeazÄƒ mesajul utilizatorului pentru a identifica intenÈ›ia exactÄƒ Ã®n funcÈ›ie de urmÄƒtoarele categorii detaliate:\n\n"
        
        "1. produs_informaÈ›ii - INCLUD È™i intenÈ›ii preliminare de cumpÄƒrare, exprimÄƒri generale, curiozitate sau cerere de categorii. Se clasificÄƒ aici orice interes pentru:\n"
        "- produse, modele, game, colecÈ›ii, serii, culori, categorii ('Ce aveÈ›i?', 'Ce modele mai sunt?', 'Mai aveÈ›i È™i alte produse?')\n"
        "- expresii generice sau incomplete: 'produse?', 'categorii?', 'alte modele?', 'impermeabile?' â€“ chiar dacÄƒ nu existÄƒ Ã®ntrebare completÄƒ\n"
        "- expresii vagi sau generale de interes: 'vreau produsul', 'doresc un model', 'aÈ™ vrea sÄƒ vÄƒd', 'ce aveÈ›i Ã®n categoria X'\n"
        "- Ã®ntrebÄƒri despre specificaÈ›ii, caracteristici, opÈ›iuni de personalizare, materiale, Ã®ntreÈ›inere\n"
        "- comparaÈ›ii Ã®ntre produse/serii\n"
        "- solicitÄƒri de imagini, cataloage, mostre\n"
        "- Ã®ntrebÄƒri despre disponibilitate, dimensiuni, stoc, livrare (doar dacÄƒ nu menÈ›ioneazÄƒ acÈ›iunea de a comanda)\n"
        "- Ã®ntrebÄƒri despre garanÈ›ie, montaj\n"
        "- menÈ›iuni despre preÈ› fÄƒrÄƒ cerere explicitÄƒ de ofertÄƒ sau acÈ›iune\n"
        "- orice exprimare incertÄƒ sau ambiguu-intenÈ›ionatÄƒ\n\n"
        
        "2. comandÄƒ - DOAR cÃ¢nd existÄƒ acÈ›iune explicitÄƒ, clar formulatÄƒ:\n"
        "- 'vreau sÄƒ comand', 'doresc sÄƒ cumpÄƒr', 'aÈ™ vrea sÄƒ achiziÈ›ionez'\n"
        "- cerere de ofertÄƒ pentru cantitate definitÄƒ: 'cÃ¢t ar costa 30 bucÄƒÈ›i', 'trimiteÈ›i-mi preÈ›ul pentru 50mp'\n"
        "- formulÄƒri despre termeni de livrare/platÄƒ pentru o tranzacÈ›ie iminentÄƒ\n"
        "- orice formulare cu verb concret de tranzacÈ›ie: 'comand', 'achiziÈ›ionez', 'cumpÄƒr', 'plÄƒtesc', 'trimiteÈ›i factura'\n"
        "- expresii de Ã®ncheiere a comenzii: 'hai sÄƒ finalizÄƒm', 'pregÄƒtiÈ›i comanda', 'vÄƒ trimit datele de facturare'\n\n"
        
        "3. altceva - doar pentru:\n"
        "- saluturi, mulÈ›umiri fÄƒrÄƒ context de afacere\n"
        "- glume, spam, comentarii irelevante\n"
        "- mesaje fÄƒrÄƒ nicio legÄƒturÄƒ cu produsele sau comenzile\n\n"
        
        "REGULI IMPORTANTE:\n"
        "- Orice menÈ›iune despre produse, game, modele, categorii sau expresii generale => produs_informaÈ›ii\n"
        "- Orice ambiguitate => produs_informaÈ›ii (mai bine fals pozitiv decÃ¢t sÄƒ ratezi o intenÈ›ie)\n"
        "- Doar cÃ¢nd existÄƒ verb clar de comandÄƒ => clasifici ca 'comandÄƒ'\n\n"
        
        "EXEMPLE CLASIFICATE:\n"
        "'Ce modele impermeabile aveÈ›i?' => produs_informaÈ›ii\n"
        "'AveÈ›i È™i alte categorii?' => produs_informaÈ›ii\n"
        "'Produse?' => produs_informaÈ›ii\n"
        "'AÈ™ dori sÄƒ vÄƒd È™i alte variante' => produs_informaÈ›ii\n"
        "'Vreau sÄƒ comand 100mp pentru luni' => comandÄƒ\n"
        "'TrimiteÈ›i factura pe email' => comandÄƒ\n"
        "'Salut, bunÄƒ' => altceva\n\n"
        
        f"Mesaj de analizat: \"{interest}\"\n\n"
        "RÄƒspunde STRICT cu unul dintre tag-uri: produs_informaÈ›ii, comandÄƒ, altceva. FÄƒrÄƒ explicaÈ›ii suplimentare."
    )


    messages = [{"role": "system", "content": interests_prompt}]
    response = ask_with_ai(messages)
    return response

@app.route("/interests", methods=["POST"])
def interests():
    user_data = request.get_json()
    interest = user_data.get("name", "prieten")

    interest_checked = check_interest(interest)
    print(interest_checked)
    if (interest_checked == "produs_informaÈ›ii"):
        messages = [
            {
                "role": "user",
                "content": (
                    "Nu spune niciodatÄƒ â€Salutâ€, gen toate chestiile introductive, pentru cÄƒ noi deja ducem o discuÈ›ie È™i ne cunoaÈ™tem. "
                    "Fa promptul frumos , foloseste emoji-uri ( este despre un business de acoperisuri ) si pentur fiecare alegere adauga un emoji in loc de numere dar trebuie ca emojiurile sa fie strict legate de business de acoperisuri ( gen cand enumeri categoriile )"
                    "Esti un chatbot inteligent care creezi un prompt interactiv si frumos pentru user si il intrebi ce produse doreste , din cele de mai jos (trebuie incluse toate in prompt fara RoofArt in fata):"
                    f"Acestea sunt toate categoriile disponibile : {categorii_unice}"
                    "Rogi userul sa raspunda cu denumirea exacta a produsului din lista de categorii"
                )
            }
        ]
    elif (interest_checked == "comandÄƒ"):
        message  = "ğŸŒŸ MulÈ›umim cÄƒ ai ales KROV! Pentru a putea procesa comanda ta cÃ¢t mai rapid, te rugÄƒm frumos sÄƒ ne spui numele È™i prenumele tÄƒu. ğŸ˜Š"
        return jsonify({"ask_interests": message})
    else:
        messages = [
            {
                "role": "user",
                "content": (
                    f"EÈ™ti un bot inteligent care rÄƒspunde la Ã®ntrebarea: {interest}. In maxim 80 tokenuri"
                    "La finalul rÄƒspunsului tÄƒu, te rog sÄƒ Ã®ntrebi utilizatorul dacÄƒ doreÈ™te sÄƒ aleagÄƒ un produs dintr-o categorie sau dacÄƒ doreÈ™te sÄƒ plaseze o comandÄƒ."
                )
            }
        ]



    response = ask_with_ai(messages, temperature= 0.9 , max_tokens= 400)

    if (interest_checked == "altceva"):
        response = response + "!!!"

    return jsonify({"ask_interests": response})

def fuzzy_check_category(user_interest, categorii_unice, threshold=70):
    user_interest = normalize_numere(user_interest)
    categorii_unice = [normalize_numere(cat) for cat in categorii_unice]

    best_match, best_score = process.extractOne(user_interest, categorii_unice, scorer=fuzz.token_set_ratio)

    if best_score >= threshold:
        return best_match

    for word in user_interest.split():
        best_match, best_score = process.extractOne(word, categorii_unice, scorer=fuzz.token_set_ratio)
        if best_score >= threshold:
            return best_match

    return "NU"


def smart_category_prompt(user_interest, categorii_unice):
    prompt = (
        "AvÃ¢nd Ã®n vedere lista de categorii:\n"
        f"{', '.join(categorii_unice)}\n"
        f"Utilizatorul a spus: '{user_interest}'\n"
        "SugereazÄƒ cea mai potrivitÄƒ categorie dintre lista de mai sus. "
        "RÄƒspunde doar cu numele categoriei, fÄƒrÄƒ alte explicaÈ›ii. "
        "DacÄƒ niciuna nu se potriveÈ™te, rÄƒspunde cu NU."
    )
    messages = [{"role": "system", "content": prompt}]
    response = ask_with_ai(messages).strip()

    if not response or response.upper() == "NU":
        return "NU"
    
    # PoÈ›i face o verificare suplimentarÄƒ sÄƒ vezi dacÄƒ rÄƒspunsul chiar face parte din categorii
    if response not in categorii_unice:
        return "NU"

    return response



def check_and_get_category(user_interest, categorii_unice, threshold=70):
    # Prima Ã®ncercare: fuzzy matching
    if is_comanda(user_interest):
        return "comandÄƒ"

    fuzzy_result = fuzzy_check_category(user_interest, categorii_unice, threshold)
    print("fuzzy = " ,fuzzy_result)

    if fuzzy_result != "NU":
        return fuzzy_result

    ai_result = smart_category_prompt(user_interest, categorii_unice)
    return ai_result



def is_comanda(user_interest):
    intentii_comanda = [
        "vreau sÄƒ comand", "vreau sa comand", "doresc sÄƒ cumpÄƒr", "as dori sa cumpar",
        "aÈ™ vrea sÄƒ achiziÈ›ionez", "comand", "achiziÈ›ionez", "cumpÄƒr", "plÄƒtesc",
        "trimiteÈ›i factura", "hai sÄƒ finalizÄƒm", "pregÄƒtiÈ›i comanda", "trimit datele"
    ]
    
    # Listez toate cuvintele din expresiile cheie
    # Cuvintele din textul user
    cuvinte_user = user_interest.lower().split()
    # Verific fuzzy matching pentru fiecare cuvÃ¢nt din user cu fiecare cuvÃ¢nt cheie
    for cuv_user in cuvinte_user:
        for cuv_cheie in intentii_comanda:
            similarity = SequenceMatcher(None, cuv_user, cuv_cheie).ratio()
            if similarity > 0.8:  # prag de similaritate
                return True
    return False

def normalize_numere(text):
    cuvinte = text.split()
    normalizate = []
    for c in cuvinte:
        print("c ==== ",c)
        try:
            num = float(c)
            normalizate.append(f"{num:.2f}")
        except:
            normalizate.append(c)
    return ' '.join(normalizate)


def check_variante(user_interest, variante_posibile):

    variante_fara_primul_cuvant = [' '.join(v.split()[1:]) for v in variante_posibile]
    # print("variante = ", variante_posibile)
    # print("user_interest = " , user_interest)
    # user_interest = normalize_numere(user_interest).lower()
    # print(user_interest)
    # print(variante_fara_primul_cuvant)
    print(user_interest)
    prompt = (
        f"VerificÄƒ dacÄƒ utilizatorul a ales exact una dintre opÈ›iunile complete oferite.\n\n"
        f"OpÈ›iuni disponibile:\n{', '.join(variante_fara_primul_cuvant)}\n\n"
        f"Utilizatorul a spus: '{user_interest}'\n\n"
        "ConsiderÄƒ cÄƒ potrivirea trebuie sÄƒ fie completÄƒ È™i exactÄƒ, Ã®nsÄƒ ignorÄƒ diferenÈ›ele de majuscule È™i spaÈ›ii la Ã®nceput/sfÃ¢rÈ™it.\n"
        "DacÄƒ rÄƒspunsul este doar o parte din opÈ›iune (de exemplu, 'china' cÃ¢nd existÄƒ 'China 0.3'), rÄƒspunde NU.\n"
        "RÄƒspunde cu un singur cuvÃ¢nt:\n"
        "- DA â€“ dacÄƒ rÄƒspunsul este fix È™i complet, exact una dintre opÈ›iuni.\n"
        "- NU â€“ dacÄƒ este incomplet, parÈ›ial sau diferit.\n\n"
        "Nu oferi explicaÈ›ii, doar DA sau NU."
    )


    messages = [{"role": "system", "content": prompt}]
    response = ask_with_ai(messages).strip().upper()
    return response


@app.route("/welcome", methods=["POST"])
def welcome():
    global counter
    data = request.json
    name = data.get("name", "")
    interests = data.get("interests", "")

    print("interests = " , interests)
    categoria_aleasa = check_and_get_category(interests, categorii_unice)
    print(categorii_unice)

    print("categoria_aleasa = " , categoria_aleasa)

    if categoria_aleasa == "NU":
        prompt = (
            f"Utilizatorul a scris categoria: '{interests}'.\n\n"
            "Nu spune niciodatÄƒ â€Salutâ€, gen toate chestiile introductive, pentru cÄƒ noi deja ducem o discuÈ›ie È™i ne cunoaÈ™tem. "
            "Scrie un mesaj politicos, prietenos È™i natural, care:\n"
            "1. RÄƒspunde pe scurt la ceea ce a spus utilizatorul . "
            "2. Apoi roagÄƒ-l politicos sÄƒ rescrie cu atenÈ›ie denumirea categoriei dorite, "
            "pentru a-l putea ajuta cÃ¢t mai bine.\n"
            "3. Mesajul sÄƒ fie scurt, cald, empatic È™i prietenos. "
            "Nu mai mult de 2-3 propoziÈ›ii.\n"
            "Nu folosi ghilimele È™i nu explica ce faci â€“ scrie doar mesajul final pentru utilizator."
        )
        messages = [{"role": "system", "content": prompt}]
        mesaj = ask_with_ai(messages).strip()
        mesaj += "!!!"

    elif categoria_aleasa == "comandÄƒ":
        mesaj = "ğŸŒŸ MulÈ›umim cÄƒ ai ales KROV! Pentru a putea procesa comanda ta cÃ¢t mai rapid, te rugÄƒm frumos sÄƒ ne spui numele È™i prenumele tÄƒu. ğŸ˜Š"
        return jsonify({"message": mesaj})
    else:
        search_key = " ".join(categoria_aleasa.split()[:2]).lower()
        sub_variante = [cat for cat in categorii_unice if search_key in cat.lower()]
        variante_fara_primul_cuvant = [' '.join(v.split()[1:]) for v in sub_variante]
        print("sub_variante = ", sub_variante)
        check_sub_variante = check_variante(interests , sub_variante)

        print("check_sub_variante = " , check_sub_variante)

        if(check_sub_variante == "NU"):
            if len(sub_variante) > 1:
                emoji_options = ["ğŸ”¹", "ğŸ”¸", "â–ªï¸", "â–«ï¸", "â—¾", "â—½"]  # Emoji-uri neutre pentru variante
                options_list = "\n".join([f"{emoji_options[i%len(emoji_options)]} {variant}" for i, variant in enumerate(variante_fara_primul_cuvant)])
                
                mesaj = (
                    f"Am gÄƒsit mai multe variante pentru '{categoria_aleasa.split()[1]}':\n\n"
                    f"{options_list}\n\n"
                    "Te rog sÄƒ alegi varianta exactÄƒ care te intereseazÄƒ. ğŸ˜Š"
                )
            else:
                preferinte["Categorie"] = categoria_aleasa
                request_categorie = categoria_preferata(categoria_aleasa)
                preferinte["Produsele"] = request_categorie
                mesaj = request_categorie
                # mesaj += " . <br><br> Care produs te intereseaza ? "
                mesaj += " . <br><br> Doriti sa aflati informatie si despre alte categorii sau doriti sa comandati ? "

        
        else:
            preferinte["Categorie"] = categoria_aleasa
            request_categorie = categoria_preferata(categoria_aleasa)
            preferinte["Produsele"] = request_categorie
            mesaj = request_categorie
            # mesaj += " . <br><br> Care produs te intereseaza ? "
            mesaj += " . <br><br> Doriti sa aflati informatie si despre alte categorii sau doriti sa comandati ? "


    return jsonify({"message": mesaj})

def check_response(user_message):
    prompt = (
        f"Utilizatorul a spus: '{user_message}'\n\n"
        "ClasificÄƒ mesajul utilizatorului Ã®ntr-una dintre urmÄƒtoarele categorii, rÄƒspunzÃ¢nd cu un singur cuvÃ¢nt:\n\n"
        "- DA: dacÄƒ mesajul exprimÄƒ o intenÈ›ie clarÄƒ È™i pozitivÄƒ, cum ar fi o confirmare, o dorinÈ›Äƒ de a merge mai departe sau un interes real. "
        "Exemple: 'Da', 'Sigur', 'AÈ™ dori', 'Sunt interesat', 'Vreau acel produs', 'Desigur', 'Perfect', 'sunt curios' etc.\n\n"
        "- NU: dacÄƒ mesajul exprimÄƒ o refuzare, o ezitare sau o lipsÄƒ de interes. "
        "Exemple: 'Nu', 'Nu acum', 'Nu sunt sigur', 'Mai tÃ¢rziu', etc.\n\n"
        "- ALTCEVA: dacÄƒ mesajul nu se Ã®ncadreazÄƒ Ã®n niciuna dintre categoriile de mai sus, de exemplu dacÄƒ utilizatorul pune o Ã®ntrebare nespecificÄƒ, schimbÄƒ subiectul sau oferÄƒ informaÈ›ii fÄƒrÄƒ legÄƒturÄƒ cu decizia, comanda sau interesul faÈ›Äƒ de produs. "
    )
    messages = [{"role": "system", "content": prompt}]
    result = ask_with_ai(messages).strip().upper()
    return result


def construieste_prompt_selectie(produse_similare):
    if not produse_similare:
        return "âš ï¸ Nu existÄƒ produse similare pentru a selecta."

    prompt = (
        "ğŸ” Am gÄƒsit mai multe produse care se potrivesc cu ce ai scris.\n"
        "ğŸ‘‡ Te rog alege unul dintre produsele de mai jos:<br>\n\n"
    )

    for i, produs in enumerate(produse_similare, start=1):
        prompt += f"{i}. ğŸ›’ {produs}<br>\n"

    prompt += "\n Scrie **numele exact** al produsului dorit"
    return prompt


def check_product(message):
    lista_produse = preferinte.get("Produsele", [])
    prompt = (
        "PrimeÈ™ti o listÄƒ de produse È™i un mesaj venit de la client.\n"
        "Scopul tÄƒu este sÄƒ identifici dacÄƒ mesajul clientului se referÄƒ clar la unul dintre produsele din listÄƒ, la mai multe produse, sau deloc.\n\n"
        "InstrucÈ›iuni:\n"
        "- DacÄƒ mesajul se potriveÈ™te clar CU UN SINGUR produs din lista normalizatÄƒ, rÄƒspunde DOAR cu numele acelui produs, exact aÈ™a cum apare Ã®n listÄƒ.\n"
        "- DacÄƒ mesajul se potriveÈ™te parÈ›ial sau ambiguu CU MAI MULTE produse din listÄƒ, rÄƒspunde cu: AMBIGUU: urmat de lista produselor potrivite separate prin virgulÄƒ (ex: AMBIGUU: Produs A, Produs B).\n"
        "- DacÄƒ mesajul NU pare sÄƒ se refere deloc la vreun produs din listÄƒ, sau conÈ›inutul este complet diferit (ex: Ã®ntrebÄƒri generale, comentarii care nu au legÄƒturÄƒ cu produse), rÄƒspunde cu: NONE\n\n"
        f"Lista de produse disponibile: {', '.join(lista_produse)}\n"
        f"Mesaj client: \"{message.strip()}\"\n"
        "RÄƒspuns:"
    )

    messages = [{"role": "system", "content": prompt}]
    response = ask_with_ai(messages).strip()

    if response.upper() == "NONE":
        return "NONE", []
    
    if response.upper().startswith("AMBIGUU"):
        _, sugestii = response.split(":", 1)
        print(sugestii)
        produse_similare = [p.strip() for p in sugestii.split(",")]
        produse_similare = construieste_prompt_selectie(produse_similare)
        return "AMBIGUU", produse_similare

    return response, []


def check_category(user_interest, categorii_unice):
    prompt = (
        "AvÃ¢nd Ã®n vedere lista de categorii:\n"
        f"{', '.join(categorii_unice)}\n"
        f"Utilizatorul a spus: '{user_interest}'\n"
        "Uite daca utilizatorul a specificat clar produsul , de exemplu daca cere tabla cutata , am mai multe variante si nu este clar , insa daca specifica ce tabla cutata atunci este bine si asa pentru toate trebuie"
        "RÄƒspunde doar cu numele produsului daca este specificat bine , fÄƒrÄƒ alte explicaÈ›ii. "
        "DacÄƒ niciuna nu se potriveÈ™te, rÄƒspunde cu NU."
    )
    messages = [{"role": "system", "content": prompt}]
    response = ask_with_ai(messages).strip()

    if not response or response.upper() == "NU":
        return "NU"
    
    # PoÈ›i face o verificare suplimentarÄƒ sÄƒ vezi dacÄƒ rÄƒspunsul chiar face parte din categorii
    if response not in categorii_unice:
        return "NU"

    return response


@app.route("/next_chat", methods=["POST"])
def next_chat():
    data = request.get_json()
    name = data.get("name", "")
    interests = data.get("interests", "")
    message = data.get("message", "")
    response,lista = check_product(message)
    print(response)
    print(lista)
    # response_name = check_category(interests,preferinte["Produsele"])
    # if response_name == "NU":
    if response == "AMBIGUU":

        return jsonify({"reply": lista})

    if response != "NONE" :
        preferinte['produs_exact'] = response
        response = (
            "ÃÈ›i mulÈ›umesc! Te rog sÄƒ-mi spui doar cantitatea doritÄƒ pentru produs, "
            "ca sÄƒ pot continua comanda ta.\n\n"
            "AÈ™tept cantitatea, mulÈ›umesc! ğŸ˜Š"
        )

    else:
        prompt = (
            "Nu trebuie sa te saluti pentru ca deja ducem o conversatie , trebuie sa raspunzi strict la mesaje ! "
            "Esti un chatbot inteligent care raspunde la intrebari intr-o maniera foarte prietenoasa ."
            "Esti chatbot-ul companiei KROV care se ocupa de acoperisuri . "
            f"Raspunde la mesajul {message} si adauga la final ca nu ai inteles ce produs si roaga userul sa mai aleaga odata produsul cu atentie . ( sa scrie fara greseli ) "
        )

        messages = [{"role": "system", "content": prompt}]
        response = ask_with_ai(messages)
        response += "!!!"

    return jsonify({"reply": response})
    

def este_cantitate_valida(message):
    
    prompt = (
        "Clientul a trimis un mesaj. Extrage, te rog,  cantitatea numericÄƒ exprimatÄƒ Ã®n orice formÄƒ. "
        "RÄƒspunde DOAR cu numÄƒrul, fÄƒrÄƒ alte cuvinte.\n\n"
        f"Mesaj: \"{message}\"\n"
        "RÄƒspuns:"
    )

    messages = [{"role": "system", "content": prompt}]
    response = ask_with_ai(messages)
    return response


def check_price(produs_exact):
    lista_produse = preferinte.get("Produsele", [])
    print("list_produse = ", lista_produse)
    print("produsul exact : " , produs_exact)
    prompt = (
        f"Extrage te rog din lista de produse {lista_produse} produsul {produs_exact} , trebuie sa imi extragi fix produsul {produs_exact} si doar pe acesta nu alta informatie te rog!!!"
    )
    messages = [{"role": "system", "content": prompt}]
    response = ask_with_ai(messages)
    return response


def extrage_total_din_text(text):
    numere = re.findall(r"(?<![a-zA-Z])(\d+(?:[.,]\d+)?)", text)
    if numere:
        return float(numere[-1].replace(",", "."))
    return None


def print_price(pret_produs, cantitate, produsul_extras):
    total = float(pret_produs) * float(cantitate)
    return (
        f"PreÈ› unitar: {pret_produs:.2f} MDL\n"
        f"PreÈ› total: {total:.2f} MDL\n"
        "DacÄƒ doriÈ›i sÄƒ comandaÈ›i sau aveÈ›i alte Ã®ntrebÄƒri, nu ezitaÈ›i sÄƒ mÄƒ Ã®ntrebaÈ›i."
    )

@app.route("/cantitate", methods=["POST"])
def cantitate():
    data = request.get_json()
    name = data.get("name", "")
    interests = data.get("interests", "")
    message = data.get("message", "")
    cantitate = este_cantitate_valida(message)
    produs_exact = preferinte['produs_exact']
    produsul_extras = check_price(produs_exact)
    print("Produsul extras : " , produsul_extras)
    pret_produs = extrage_total_din_text(produsul_extras)
    print(pret_produs)
    print_frumos = print_price(pret_produs,cantitate,produsul_extras)
    # print(print_frumos)
    return jsonify({"reply": print_frumos})

@app.route("/chat", methods=["POST"])
def chat():
    data = request.get_json()
    name = data.get("name", "")
    interests = data.get("interests", "")
    message = data.get("message", "")
    response = check_response(message)
    print("raspuns = " , response)
    if response == "DA":
        messages = [
            {
                "role": "system",
                "content": (
                    "Nu spune niciodatÄƒ â€Salutâ€, gen toate chestiile introductive, pentru cÄƒ noi deja ducem o discuÈ›ie È™i ne cunoaÈ™tem. "
                    "Fa promptul frumos , foloseste emoji-uri ( este despre un business de acoperisuri ) si pentur fiecare alegere adauga un emoji in loc de numere dar trebuie ca emojiurile sa fie strict legate de business de acoperisuri ( gen cand enumeri categoriile )"
                    "Esti un chatbot inteligent care creezi un prompt interactiv si frumos pentru user si il intrebi ce produse doreste , din cele de mai jos (trebuie incluse toate in prompt fara RoofArt in fata):"
                    f"Acestea sunt toate categoriile disponibile : {categorii_unice} , afiseaza-le pe toate"
                    "Afiseaza toate categoriile diponibile , nu scapa niciunu"
                    "Rogi userul sa raspunda cu denumirea exacta a produsului"
                )
            }
        ]

    elif response == "NU":
        messages = [
            {
                "role": "system",
                "content": (
                    "ÃÈ›i mulÈ›umesc pentru conversaÈ›ie! ğŸ™ DacÄƒ vei avea Ã®ntrebÄƒri sau vei dori sÄƒ afli mai multe despre produsele noastre, "
                    "sunt aici oricÃ¢nd pentru tine. ğŸ ğŸ’¬\n"
                    "ÃÈ›i doresc o zi frumoasÄƒ È™i succes Ã®n proiectul tÄƒu de acoperiÈ™! â˜€ï¸ğŸ”¨"
                )
            }
        ]
        messages[0]['content'] += "!!!"
    else:
        messages = [
            {
                "role": "system",
                "content": (
                    f"Utilizatorul a scris categoria: '{interests}'.\n\n"
                    "Nu spune niciodatÄƒ â€Salutâ€, gen toate chestiile introductive, pentru cÄƒ noi deja ducem o discuÈ›ie È™i ne cunoaÈ™tem. "
                    "Scrie un mesaj politicos, prietenos È™i natural, care:\n"
                    "1. RÄƒspunde pe scurt la ceea ce a spus utilizatorul . "
                    "2. Apoi roagÄƒ-l politicos sÄƒ raspunda daca doreste sa afle despre alt produs cu Da/Nu . "
                )
            }
        ]


    reply = ask_with_ai(messages, temperature=0.9 , max_tokens= 400)

    # reply = response.choices[0].message.content.strip()
    # log_message("AI BOT", reply)
    return jsonify({"reply": reply})


@app.route("/comanda", methods=["POST"])
def comanda():
    data = request.get_json()
    name = data.get("name", "")
    interests = data.get("interests", "")
    message = data.get("message", "")
    print("1111")

    return jsonify({"reply": message})


def ask_with_ai(messages , temperature = 0.9 , max_tokens = 100):
    response = openai.chat.completions.create(
        model="gpt-4o-mini",
        messages=messages,
        temperature=temperature,
        max_tokens=max_tokens
    )
    return response.choices[0].message.content.strip()






if __name__ == "__main__":
    app.run(debug=True, use_reloader=False)
